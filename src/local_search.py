"""
Warning: This file was primarily generated by Claude Opus 4.5
"""

from __future__ import annotations

import ctypes
from ctypes import wintypes
from typing import Any, Callable, List, Optional
import os

import numpy as np

from utils.solution import Solution
from generator import Instance


# Win32 API for loading DLL
kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)

LoadLibrary = kernel32.LoadLibraryW
LoadLibrary.argtypes = [wintypes.LPCWSTR]
LoadLibrary.restype = wintypes.HMODULE

GetProcAddress = kernel32.GetProcAddress
GetProcAddress.argtypes = [wintypes.HMODULE, wintypes.LPCSTR]
GetProcAddress.restype = ctypes.c_void_p

FreeLibrary = kernel32.FreeLibrary
FreeLibrary.argtypes = [wintypes.HMODULE]
FreeLibrary.restype = wintypes.BOOL

# Define the function prototype for the solve function
# uint8_t solve(
#     uint64_t vehicles_count,
#     uint64_t customers_count,
#     uint64_t *capacities,
#     uint64_t **time_matrix,
#     uint64_t *demands,
#     uint64_t *ready_times,
#     uint64_t *due_dates,
#     uint64_t *service_times,
#     uint64_t depot,
#     uint64_t time_limit_ms,
#     uint64_t *out_cost,
#     uint64_t *out_elapsed_ms,
#     uint8_t *out_timed_out,
#     const char **out_error_message,
#     const char **out_status);

SOLVE_FUNC_TYPE = ctypes.CFUNCTYPE(
    ctypes.c_uint8,                              # return type
    ctypes.c_uint64,                             # vehicles_count
    ctypes.c_uint64,                             # customers_count
    ctypes.POINTER(ctypes.c_uint64),             # capacities
    ctypes.POINTER(ctypes.POINTER(ctypes.c_uint64)),  # time_matrix
    ctypes.POINTER(ctypes.c_uint64),             # demands
    ctypes.POINTER(ctypes.c_uint64),             # ready_times
    ctypes.POINTER(ctypes.c_uint64),             # due_dates
    ctypes.POINTER(ctypes.c_uint64),             # service_times
    ctypes.c_uint64,                             # depot
    ctypes.c_uint64,                             # time_limit_ms
    ctypes.POINTER(ctypes.c_uint64),             # out_cost
    ctypes.POINTER(ctypes.c_uint64),             # out_elapsed_ms
    ctypes.POINTER(ctypes.c_uint8),              # out_timed_out
    ctypes.POINTER(ctypes.c_char_p),             # out_error_message
    ctypes.POINTER(ctypes.c_char_p),             # out_status
)


class LocalSearchSolver:
    """CVRPTW solver using native local search DLL."""

    # Default DLL path relative to project root
    DEFAULT_DLL_PATH = os.path.join(
        os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
        "local_search", "build", "liblocal_search.dll"
    )

    def __init__(self, timeout: float = 1.0, dll_path: Optional[str] = None) -> None:
        self.timeout: float = timeout  # seconds
        self.dll_path = dll_path or self.DEFAULT_DLL_PATH
        self._dll_handle: Optional[wintypes.HMODULE] = None
        self._solve_func: Optional[Callable[..., Any]] = None

    def _load_dll(self) -> None:
        """Load the DLL and get the solve function pointer."""
        if self._dll_handle is not None:
            return

        # Load the DLL
        self._dll_handle = LoadLibrary(self.dll_path)
        if not self._dll_handle:
            error = ctypes.get_last_error()
            raise OSError(
                f"Failed to load DLL '{self.dll_path}': error code {error}")

        # Get the solve function address
        func_addr = GetProcAddress(self._dll_handle, b"solve")
        if not func_addr:
            error = ctypes.get_last_error()
            FreeLibrary(self._dll_handle)
            self._dll_handle = None
            raise OSError(
                f"Failed to get 'solve' function address: error code {error}")

        # Cast to the function type
        self._solve_func = SOLVE_FUNC_TYPE(func_addr)

    def _unload_dll(self) -> None:
        """Unload the DLL."""
        if self._dll_handle is not None:
            FreeLibrary(self._dll_handle)
            self._dll_handle = None
            self._solve_func = None

    def __del__(self) -> None:
        self._unload_dll()

    def solve(self, inst: Instance) -> Solution:
        """
        Solve the CVRPTW instance using the native local search library.

        Args:
            inst: The CVRPTW instance to solve.

        Returns:
            A Solution object with the result.
        """
        # Load DLL if not already loaded
        self._load_dll()
        assert self._solve_func is not None

        n_nodes = int(inst.n_nodes)          # = n + 2, nodes 0..n+1
        n = int(inst.n_customers)            # customers 1..n
        K = int(inst.K)
        Q = int(inst.Q)

        dist = np.asarray(inst.dist, dtype=np.float64)
        service = np.asarray(inst.service, dtype=np.float64)
        demand = np.asarray(inst.demand, dtype=np.int64)
        tw = np.asarray(inst.tw, dtype=np.float64)
        ready_times = tw[:, 0]
        due_dates = tw[:, 1]

        # Scale factor for converting float to uint64
        scale = 1000

        # Prepare input arrays (scale floats to integers)
        # Capacities: one per vehicle, all same
        capacities = np.full(K, Q, dtype=np.uint64)

        # Time matrix: (n_nodes, n_nodes) scaled to uint64
        # Include service time in travel time (from node i to j: dist[i,j] + service[i])
        time_matrix_float = dist + service[:, np.newaxis]
        time_matrix = (time_matrix_float * scale).astype(np.uint64)

        # Demands
        demands_arr = demand.astype(np.uint64)

        # Ready times and due dates (scaled)
        ready_times_arr = (ready_times * scale).astype(np.uint64)
        due_dates_arr = (due_dates * scale).astype(np.uint64)

        # Service times (scaled)
        service_times_arr = (service * scale).astype(np.uint64)

        # Depot is node 0
        depot = 0

        # Time limit in milliseconds
        time_limit_ms = int(self.timeout * 1000)

        # Create ctypes arrays
        c_capacities = capacities.ctypes.data_as(
            ctypes.POINTER(ctypes.c_uint64))
        c_demands = demands_arr.ctypes.data_as(ctypes.POINTER(ctypes.c_uint64))
        c_ready_times = ready_times_arr.ctypes.data_as(
            ctypes.POINTER(ctypes.c_uint64))
        c_due_dates = due_dates_arr.ctypes.data_as(
            ctypes.POINTER(ctypes.c_uint64))
        c_service_times = service_times_arr.ctypes.data_as(
            ctypes.POINTER(ctypes.c_uint64))

        # Time matrix as array of row pointers
        row_pointers = (ctypes.POINTER(ctypes.c_uint64) * n_nodes)()
        for i in range(n_nodes):
            row_pointers[i] = time_matrix[i].ctypes.data_as(
                ctypes.POINTER(ctypes.c_uint64))
        c_time_matrix = ctypes.cast(
            row_pointers, ctypes.POINTER(ctypes.POINTER(ctypes.c_uint64)))

        # Output variables
        out_cost = ctypes.c_uint64(0)
        out_elapsed_ms = ctypes.c_uint64(0)
        out_timed_out = ctypes.c_uint8(0)
        out_error_message = ctypes.c_char_p()
        out_status = ctypes.c_char_p()

        # Call the solve function
        result = self._solve_func(
            ctypes.c_uint64(K),
            ctypes.c_uint64(n_nodes),
            c_capacities,
            c_time_matrix,
            c_demands,
            c_ready_times,
            c_due_dates,
            c_service_times,
            ctypes.c_uint64(depot),
            ctypes.c_uint64(time_limit_ms),
            ctypes.byref(out_cost),
            ctypes.byref(out_elapsed_ms),
            ctypes.byref(out_timed_out),
            ctypes.byref(out_error_message),
            ctypes.byref(out_status),
        )

        # Parse the result
        status_str = out_status.value.decode(
            'utf-8') if out_status.value else "ERROR"
        error_msg = out_error_message.value.decode(
            'utf-8') if out_error_message.value else None

        if result != 0 or error_msg:
            # Error occurred
            return Solution(
                status="ERROR",
                objective=float("inf"),
                routes=[],
            )

        # Convert cost back to float (unscale)
        objective = float(out_cost.value) / scale

        # Map status string to SolveStatus
        status_map = {
            "OPTIMAL": "OPTIMAL",
            "FEASIBLE": "FEASIBLE",
            "INFEASIBLE": "INFEASIBLE",
            "NO_SOLUTION": "NO_SOLUTION",
        }
        solve_status = status_map.get(status_str, "ERROR")

        # Note: The C API doesn't return routes, so we return empty routes
        # A more complete implementation would need the C API to output routes
        routes: List[List[int]] = []

        return Solution(
            status=solve_status,
            objective=objective,
            routes=routes,
        )
